[toc]

linux的五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。其中阻塞IO、非阻塞IO、多路复用IO、信号驱动IO都属于同步IO。

##### 1、什么是NIO?

java.nio全称java non-blocking IO（实际上是 new io），是指JDK 1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供[缓存](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E7%BC%93%E5%AD%98/100710)支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。

##### 2、为什么用NIO，传统IO有什么缺陷？

1. ==线程不够用==， 就算使用了线程池复用线程也无济于事;
2. 阻塞I/O模式下，会有==大量的线程被阻塞==，一直在等待数据，这个时候的线程被挂起，只能干等，CPU利用率很低，换句话说，系统的吞吐量差;
3. 如果网络I/O堵塞或者有网络抖动或者网络故障等，线程的阻塞时间可能很长。

​        当服务器与客户端进行通讯时，每加入一台客户端需要一个IO线程阻塞等待对方数据传送，会导致服务器不断开启线程，但这些线程大部分时间都是阻塞在那里，浪费资源，并且支持不了大并发。

##### 3、NIO和IO的区别

==原有的 IO 是面向流的、阻塞的，NIO 则是面向块（缓冲区）的、非阻塞的。==

​		原始的IO是面向流的，不存在缓存的概念。Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区Java IO的各种流是阻塞的，这意味着当一个线程调用read或 write方法时，该线程被阻塞，直到有一些数据被读取，或数据完全写入，该线程在此期间不能再干任何事情了。

##### 4、BIO/NIO/AIO有什么区别？

|                             BIO                              |                             NIO                              |                             AIO                              |
| :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|                          同步并阻塞                          |                          同步非阻塞                          |                          异步非阻塞                          |
| 服务器实现模式为==一个连接一个线程==，即客户端有连接请求时服务器端就需要启动一个线程并处理，如果这个连接不做任何事情会造成不必要的开销，当然可以通过线程池机制改善 | 服务器实现模式为==一个请求一个线程==，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理 | 服务器实现模式为==一个有效请求一个线程==，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理 |
| 适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。 | 适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。 | 适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 |

##### 5、select、poll、eopll的区别

**阻塞IO**, 给女神发一条短信, 说我来找你了, 然后就默默的一直等着女神下楼, 这个期间除了等待你不会做其他事情, 属于备胎做法.
**非阻塞IO**, 给女神发短信, 如果不回, 接着再发, 一直发到女神下楼, 这个期间你除了发短信等待不会做其他事情, 属于专一做法.
**IO多路复用**, 是找一个宿管大妈来帮你监视下楼的女生, 这个期间你可以些其他的事情. 例如可以顺便看看其他妹子,玩玩王者荣耀, 上个厕所等等. IO复用又包括 select, poll, epoll 模式. 那么它们的区别是什么?

- 1） **select大妈** 每一个女生下楼, select大妈都不知道这个是不是你的女神, 她需要一个一个询问, 并且select大妈能力还有限, 最多一次帮你监视1024个妹子

- 2） **poll大妈**不限制盯着女生的数量, 只要是经过宿舍楼门口的女生, 都会帮你去问是不是你女神

- 3） **epoll大妈**不限制盯着女生的数量, 并且也不需要一个一个去问. 那么如何做呢? epoll大妈会为每个进宿舍楼的女生脸上贴上一个大字条,上面写上女生自己的名字, 只要女生下楼了, epoll大妈就知道这个是不是你女神了, 然后大妈再通知你。
  上面这些同步IO有一个共同点就是, 当女神走出宿舍门口的时候, 你已经站在宿舍门口等着女神的, 此时你属于**阻塞状态**

  接下来是**异步IO**的情况：
  你告诉女神我来了, 然后你就去打游戏了, 一直到女神下楼了, 发现找不见你了, 女神再给你打电话通知你, 说我下楼了, 你在哪呢? 这时候你才来到宿舍门口。 此时属于逆袭做法

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

|                            select                            |                  poll                  |                            eopll                             |
| :----------------------------------------------------------: | :------------------------------------: | :----------------------------------------------------------: |
|                     一般操作系统均有实现                     |                                        |                         Linux所特有                          |
| 最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64） | 没有最大连接数的限制（基于链表来存储） | 1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接 |



##### 参考：

https://www.jianshu.com/p/d1ffacb5829b

https://zhuanlan.zhihu.com/p/127911769

